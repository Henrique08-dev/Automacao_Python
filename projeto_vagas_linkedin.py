# -*- coding: utf-8 -*-
"""Projeto_Vagas_LinkedIn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Tl266Df9oDtKH_Ekrvl9k8k5EONO9yg-
"""

#Importando bibliotecas necessárias para o projeto
from requests import get
from bs4 import BeautifulSoup
import pandas as pd
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

#Adicionando dicionário de geoIDS
geoIds = {
    "Brasil": "106057199",
    "Estados Unidos": "103644278",
}

#Função para enviar as vagas por email
def enviar_email(vagas_recentes, destinatario):
  remetente = "he.fla3@gmail.com"
  senha = "enuu awro vbas ahoh"
  assunto = "Vagas Recentes do LinkedIn"

  #Corpo do email
  corpo_email = "<h2>Vagas Recentes (últimas 24h)</h2>"
  for vaga in vagas_recentes:
      corpo_email += f"""
      <p>
      <b>Título:</b> {vaga['titulo']}<br>
      <b>Empresa:</b> {vaga['empresa']}<br>
      <b>Postado há:</b> {vaga['tempo']}<br>
      <b>Link:</b> <a href="{vaga['link']}">{vaga['link']}</a>
      </p>
      <hr>
      """

  #Criando a mensagem MIME
  msg = MIMEMultipart()
  msg["From"] = remetente
  msg["To"] = destinatario
  msg["Subject"] = assunto
  msg.attach(MIMEText(corpo_email, "html"))

  try:
      with smtplib.SMTP("smtp.gmail.com", 587) as servidor:
          servidor.starttls()
          servidor.login(remetente, senha)
          servidor.send_message(msg)
          print("E-mail enviado com sucesso!")
  except Exception as e:
      print(f"Erro ao enviar e-mail: {e}")

#Função para tratar url de acordo com espaçamento do LinkedIn
def tratar(texto):
  return texto.strip().replace(" ", "%20") if texto else ""

#Perguntando por quais filtros o usuário quer realizar a busca
print("Filtros existentes: País, Estado, Cidade, Categoria da Vaga, Nível Experiência, Número Páginas da Varredura")
escolha_usuario = int(input("Escolha os filtros que deseja buscar para a vaga: 1- Todos, 2- Apenas por País, 3- País, Estado e Cidade: "))

#Inicializando as variáveis vazias para não resgatar nada da memória
nome_vaga = ""
nome_pais = ""
nome_estado = ""
nome_cidade = ""
categoria_vaga = ""
nivel_experiencia = ""
numero_paginas = 1

if escolha_usuario == 1:
  nome_vaga = input("Digite o nome da vaga desejada: ")
  nome_pais = input("Digite o nome do País: ")
  nome_estado = input("Digite o nome do Estado: ")
  nome_cidade = input("Digite o nome da Cidade: ")
  categoria_vaga = int(input("Modelo de trabalho: Presencial = 1, Remoto = 2 e Híbrido = 3: "))
  nivel_experiencia = int(input("Qual o nível de experiência que busca: Estágio = 1, Assistente = 2, Júnior = 3, Pleno-Sênior = 4 e Diretor = 5: "))
  numero_paginas = int(input("Digite em quantas páginas quer fazer a varredura: "))
elif escolha_usuario == 2:
  nome_vaga = input("Digite o nome da vaga desejada: ")
  nome_pais = input("Digite o nome do País: ")
  categoria_vaga = int(input("Modelo de trabalho: Presencial = 1, Remoto = 2 e Híbrido = 3: "))
  nivel_experiencia = int(input("Qual o nível de experiência que busca: Estágio = 1, Assistente = 2, Júnior = 3, Pleno-Sênior = 4 e Diretor = 5: "))
  numero_paginas = int(input("Digite em quantas páginas quer fazer a varredura: "))
elif escolha_usuario == 3:
  nome_vaga = input("Digite o nome da vaga desejada: ")
  nome_pais = input("Digite o nome do País: ")
  nome_estado = input("Digite o nome do Estado: ")
  nome_cidade = input("Digite o nome da Cidade: ")
  numero_paginas = int(input("Digite em quantas páginas quer fazer a varredura: "))
else:
  print("Digite uma opção válida!")
  exit()

#Chamando função de tratamento
vaga_tratada = tratar(nome_vaga)
pais_tratado = tratar(nome_pais)
estado_tratado = tratar(nome_estado)
cidade_tratada = tratar(nome_cidade)

#Construção dinâmica da URL de acordo com os filtros solicitados
base_url = "https://www.linkedin.com/jobs/search?"
parametros = []

if vaga_tratada:
    parametros.append(f"keywords={vaga_tratada}")

#Localização com geoId, se existir
geoId = geoIds.get(nome_pais, "")
if cidade_tratada or estado_tratado or pais_tratado:
    localizacao = "%2C%20".join(filter(None, [cidade_tratada, estado_tratado, pais_tratado]))
    parametros.append(f"location={localizacao}")
    if geoId:
        parametros.append(f"geoId={geoId}")

if categoria_vaga:
    parametros.append(f"f_WT={categoria_vaga}")
if nivel_experiencia:
    parametros.append(f"f_E={nivel_experiencia}")
if numero_paginas:
    parametros.append(f"pageNum={numero_paginas}")

url = base_url + "&".join(parametros)

url

#Utilizando a biblioteca requests para fazer uma requisição de "pegar" o código fonte da URL
resposta = get(url).text

#Utilizando a biblioteca bs4 para transformar o código fonte de text para HTML
resposta_tratada = BeautifulSoup(resposta, "html.parser")

vagas = resposta_tratada.find_all("div", class_ = "base-card")

vagas_recentes = [] #Lista para armazenar as vagas válidas

for palavra in vagas:
    h3 = palavra.find("h3")
    h4 = palavra.find("h4")
    time_tag = palavra.find("time")
    a_tag = palavra.find("a")

    #Verifica se as informações essenciais existem
    if not (h3 and h4 and time_tag and a_tag and a_tag.has_attr('href')):
        continue

    titulo = h3.text.strip()
    empresa = h4.text.strip()
    tempo_postado = time_tag.text.strip().lower()
    link = a_tag['href'].strip()

    #Filtra apenas vagas postadas há menos de 24 horas
    horas = 0
    if "hour" in tempo_postado:
        horas = int(tempo_postado.split()[0])
    elif "minute" in tempo_postado:
        horas = 0
    elif "day" in tempo_postado:
        horas = int(tempo_postado.split()[0]) * 24
    else:
        continue

    if horas <= 24:
        vagas_recentes.append({
            "titulo": titulo,
            "empresa": empresa,
            "tempo": tempo_postado,
            "link": link,
            "horas": horas
        })

#Ordenando as vagas das mais recentas para as mais antigas.
vagas_recentes.sort(key=lambda x: x["horas"])

#Exibindo os resultados formatados
for vaga in vagas_recentes:
    print(f"Título: {vaga['titulo']}")
    print(f"Empresa: {vaga['empresa']}")
    print(f"Postado há: {vaga['tempo']}")
    print(f"Link: {vaga['link']}")
    print("-" * 50)

while True:
  destinatario = input("Digite o email para receber as vagas:")
  enviar_email(vagas_recentes, destinatario)

  repetir = input("Deseja enviar para mais uma pessoa? (sim/não): ").strip().lower()
  if repetir != "sim":
    print("Envio concluído, programa finalizado!")
    break
  else:
    print("Nenhuma vaga postada nas últimas 24 horas.")